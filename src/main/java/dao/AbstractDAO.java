package dao;

import java.beans.IntrospectionException;
import java.beans.PropertyDescriptor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

import database.ConnectionFactory;

/**
 * This class defines all the generic methods that one can use in order to
 * extract information about the business models from the database.
 * 
 * @author Bogdan Paun
 */
public class AbstractDAO<T> {

	protected static final Logger LOGGER = Logger.getLogger(AbstractDAO.class.getName());
	private final Class<T> type;

	@SuppressWarnings("unchecked")
	public AbstractDAO() {
		this.type = (Class<T>) ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0];
	}

	/**
	 * Returns an entity object fetched from the database based on the field name
	 * and field value given as arguments.
	 * <p>
	 * 
	 * @param field the field name
	 * @param value the value of the field name
	 * @return the entity fetched from the database
	 */
	public T findByField(String field, Object value) {
		Connection connection = null;
		PreparedStatement statement = null;
		ResultSet resultSet = null;
		String query = createSelectQuery(field);
		try {
			connection = ConnectionFactory.getConnection();
			statement = connection.prepareStatement(query);
			statement.setObject(1, value);
			resultSet = statement.executeQuery();

			return createObjects(resultSet).get(0);
		} catch (SQLException e) {
			LOGGER.log(Level.WARNING, type.getName() + "DAO:findBy " + field + " " + e.getMessage());
		} finally {
			ConnectionFactory.close(resultSet);
			ConnectionFactory.close(statement);
			ConnectionFactory.close(connection);
		}
		return null;
	}

	/**
	 * Returns a list of entities from the resultSet obtained from querying the
	 * database.
	 * <p>
	 * 
	 * @param resultSet the resultSet generated by the query
	 * @return a list of entities
	 */
	private List<T> createObjects(ResultSet resultSet) {
		List<T> list = new ArrayList<>();
		try {
			while (resultSet.next()) {
				T instance = type.newInstance();
				for (Field field : type.getDeclaredFields()) {
					Object value = resultSet.getObject(field.getName());
					PropertyDescriptor propertyDescriptor = new PropertyDescriptor(field.getName(), type);
					Method method = propertyDescriptor.getWriteMethod();
					method.invoke(instance, value);
				}
				list.add(instance);
			}
		} catch (InstantiationException | IllegalAccessException | SecurityException | IllegalArgumentException
				| InvocationTargetException | SQLException | IntrospectionException e) {
			e.printStackTrace();
		}
		return list;
	}

	/**
	 * Returns a list of entities from the resultSet obtained from querying the
	 * database. The entities are constructed using reflection techniques.
	 * <p>
	 * 
	 * @return a list of entities
	 */
	public List<T> findAll() {
		Connection connection = null;
		PreparedStatement statement = null;
		ResultSet resultSet = null;
		String query = "SELECT * FROM " + type.getSimpleName();
		try {
			connection = ConnectionFactory.getConnection();
			statement = connection.prepareStatement(query);
			resultSet = statement.executeQuery();
			return createObjects(resultSet);
		} catch (SQLException e) {
			LOGGER.log(Level.WARNING, type.getName() + "DAO:findAll " + e.getMessage());
		} finally {
			ConnectionFactory.close(resultSet);
			ConnectionFactory.close(statement);
			ConnectionFactory.close(connection);
		}
		return Collections.emptyList();
	}

	/**
	 * Adds a new entity to the database and returns the id of the inserted entity.
	 * If insertion fails, it returns -1.
	 * <p>
	 * 
	 * @param t the entity to be inserted
	 * @return the index of the newly inserted entity
	 */
	public int insert(T t) {
		Connection connection = null;
		PreparedStatement insertStatement = null;
		ResultSet resultSet = null;
		int insertedId = -1;
		String query = buildInsertStatement(t);
		try {
			connection = ConnectionFactory.getConnection();
			insertStatement = connection.prepareStatement(query, PreparedStatement.RETURN_GENERATED_KEYS);
			insertStatement.executeUpdate();
			resultSet = insertStatement.getGeneratedKeys();
			if (resultSet.next()) {
				insertedId = resultSet.getInt(1);
			}
		} catch (SQLException e) {
			LOGGER.log(Level.WARNING, "DAO:insert " + e.getMessage());
		} finally {
			ConnectionFactory.close(insertStatement);
			ConnectionFactory.close(resultSet);
			ConnectionFactory.close(connection);
		}
		return insertedId;
	}

	/**
	 * Updates the fields of a given entity without altering the id.
	 * <p>
	 * 
	 * @param t the entity to be updated
	 */
	public void update(T t) {
		Connection connection = null;
		PreparedStatement insertStatement = null;
		String query = buildUpdateStatement(t);
		try {
			connection = ConnectionFactory.getConnection();
			insertStatement = connection.prepareStatement(query);
			insertStatement.executeUpdate();
		} catch (SQLException e) {
			LOGGER.log(Level.WARNING, "DAO:update " + e.getMessage());
		} finally {
			ConnectionFactory.close(insertStatement);
			ConnectionFactory.close(connection);
		}
	}

	/**
	 * Removes a given entity from the database based on its id.
	 * <p>
	 * 
	 * @param id the id of the entity to be removed
	 */
	public void remove(int id) {
		Connection connection = null;
		PreparedStatement insertStatement = null;
		try {
			String query = "DELETE FROM " + type.getSimpleName() + " WHERE id = " + id;
			connection = ConnectionFactory.getConnection();
			insertStatement = connection.prepareStatement(query);
			insertStatement.executeUpdate();
		} catch (SQLException e) {
			LOGGER.log(Level.WARNING, "DAO:update " + e.getMessage());
		} catch (IllegalArgumentException e) {
			e.printStackTrace();
		} finally {
			ConnectionFactory.close(insertStatement);
			ConnectionFactory.close(connection);
		}
	}

	/**
	 * Retrieves the id of the next entity that will be inserted in the database.
	 * <p>
	 * 
	 * @return the id of the next entity
	 */
	public int findNextId() {
		Connection connection = null;
		PreparedStatement statement = null;
		ResultSet resultSet = null;
		String query = "SELECT id FROM " + type.getSimpleName() + " ORDER BY id DESC LIMIT 1";

		int nextId = -1;

		try {
			connection = ConnectionFactory.getConnection();
			statement = connection.prepareStatement(query);
			resultSet = statement.executeQuery();
			while (resultSet.next()) {
				nextId = resultSet.getInt(1);
			}
		} catch (SQLException e) {
			LOGGER.log(Level.WARNING, "DAO:nextId " + e.getMessage());
		} finally {
			ConnectionFactory.close(resultSet);
			ConnectionFactory.close(statement);
			ConnectionFactory.close(connection);
		}
		return nextId;
	}

	/**
	 * Creates a select query based on the given field.
	 * <p>
	 * 
	 * @param field the selection field
	 * @return the select query
	 */
	private String createSelectQuery(String field) {
		StringBuilder sb = new StringBuilder("SELECT");
		return sb.append(" * ").append("FROM ").append(type.getSimpleName()).append(" WHERE " + field + " = ?")
				.toString();
	}

	/**
	 * Retrieves a string with the fields names from a given entity.
	 * <p>
	 * 
	 * @param t the entity
	 * @return fields names separated by a comma
	 */
	private String getFieldsNames(T t) {
		StringBuilder sb = new StringBuilder();
		Field[] fields = t.getClass().getDeclaredFields();
		for (int i = 1; i < fields.length; i++) {
			fields[i].setAccessible(true);
			try {
				sb.append(fields[i].getName());
				if (i < fields.length - 1) {
					sb.append(", ");
				}
			} catch (IllegalArgumentException e) {
				e.printStackTrace();
			}
		}
		return sb.toString();
	}

	/**
	 * Retrieves a string with the fields values from a given entity.
	 * <p>
	 * 
	 * @param t the entity
	 * @return fields values separated by a comma
	 */
	private String getFieldsValues(T t) {
		StringBuilder sb = new StringBuilder();
		Field[] fields = t.getClass().getDeclaredFields();
		for (int i = 1; i < fields.length; i++) {
			fields[i].setAccessible(true);
			try {
				if (!fields[i].getType().toString().equals("int") && !fields[i].getType().toString().equals("float")) {
					sb.append("'").append(fields[i].get(t)).append("'");
				} else {
					sb.append(fields[i].get(t));
				}
				if (i < fields.length - 1) {
					sb.append(", ");
				}
			} catch (IllegalArgumentException | IllegalAccessException e) {
				e.printStackTrace();
			}
		}
		return sb.toString();
	}

	/**
	 * Creates an insert query for a given entity.
	 * <p>
	 * 
	 * @param t the entity to be inserted
	 * @return the insert query
	 */
	private String buildInsertStatement(T t) {
		return "INSERT INTO " + type.getSimpleName() + "(" + getFieldsNames(t) + ") VALUES (" + getFieldsValues(t)
				+ ");";
	}

	/**
	 * Creates an update query of a given entity.
	 * <p>
	 * 
	 * @param t the entity to be updated
	 * @return the update query
	 */
	private String buildUpdateStatement(T t) {
		StringBuilder sb = new StringBuilder("UPDATE " + type.getSimpleName() + " SET ");
		Field[] fields = t.getClass().getDeclaredFields();
		fields[0].setAccessible(true);
		for (int i = 1; i < fields.length; i++) {
			fields[i].setAccessible(true);
			Object value;
			try {
				value = fields[i].get(t);
				sb.append(fields[i].getName()).append(" = ");
				if (!fields[i].getType().toString().equals("int") && !fields[i].getType().toString().equals("float")) {
					sb.append("'").append(value).append("'");
				} else {
					sb.append(value);
				}
				if (i < fields.length - 1) {
					sb.append(", ");
				} else {
					sb.append(" WHERE id = ").append(fields[0].get(t));
				}
			} catch (IllegalArgumentException | IllegalAccessException e) {
				e.printStackTrace();
			}
		}
		return sb.toString();
	}
}
